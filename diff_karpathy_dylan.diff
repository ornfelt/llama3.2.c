diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..033df5f
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+.venv
+__pycache__
diff --git a/Makefile b/Makefile
index 6fdf747..ffba3c8 100644
--- a/Makefile
+++ b/Makefile
@@ -5,14 +5,14 @@ CC = gcc
 # the most basic way of building that is most likely to work on most systems
 .PHONY: run
 run: run.c
-	$(CC) -O3 -o run run.c -lm
-	$(CC) -O3 -o runq runq.c -lm
+	$(CC) -O3 -o run run.c -lm -lpcre 
+	$(CC) -O3 -o runq runq.c -lm -lpcre
 
 # useful for a debug build, can then e.g. analyze with valgrind, example:
 # $ valgrind --leak-check=full ./run out/model.bin -n 3
 rundebug: run.c
-	$(CC) -g -o run run.c -lm
-	$(CC) -g -o runq runq.c -lm
+	$(CC) -g -o run run.c -lm -lpcre
+	$(CC) -g -o runq runq.c -lm -lpcre
 
 # https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html
 # https://simonbyrne.github.io/notes/fastmath/
@@ -25,16 +25,16 @@ rundebug: run.c
 # In our specific application this is *probably* okay to use
 .PHONY: runfast
 runfast: run.c
-	$(CC) -Ofast -o run run.c -lm
-	$(CC) -Ofast -o runq runq.c -lm
+	$(CC) -Ofast -o run run.c -lm -lpcre
+	$(CC) -Ofast -o runq runq.c -lm -lpcre
 
 # additionally compiles with OpenMP, allowing multithreaded runs
 # make sure to also enable multiple threads when running, e.g.:
 # OMP_NUM_THREADS=4 ./run out/model.bin
 .PHONY: runomp
 runomp: run.c
-	$(CC) -Ofast -fopenmp -march=native run.c  -lm  -o run
-	$(CC) -Ofast -fopenmp -march=native runq.c  -lm  -o runq
+	$(CC) -Ofast -fopenmp -march=native run.c -lpcre -lm  -o run
+	$(CC) -Ofast -fopenmp -march=native runq.c -lpcre -lm  -o runq
 
 .PHONY: win64
 win64:
@@ -67,7 +67,7 @@ testc:
 VERBOSITY ?= 0
 .PHONY: testcc
 testcc:
-	$(CC) -DVERBOSITY=$(VERBOSITY) -O3 -o testc test.c -lm
+	$(CC) -DVERBOSITY=$(VERBOSITY) -O3 -o testc test.c -lm -lpcre
 	./testc
 
 .PHONY: clean
diff --git a/README.md b/README.md
index 8221f8d..e969cb3 100644
--- a/README.md
+++ b/README.md
@@ -1,25 +1,20 @@
-## llama2.c
+## llama3.2.c - clone of Karpathy's llama2.c but updated to work with Llama 3.2 family models.
+
+You can see [the original repo](https://github.com/karpathy/llama2.c) for a fullstack train+inference solution for llama2. I only updated the inference code [run.c](run.c) to use Llama 3.2 so if you want to train you will need to update the repo yourself.
 
 <p align="center">
   <img src="assets/llama_cute.jpg" width="300" height="300" alt="Cute Llama">
 </p>
 
-Have you ever wanted to inference a baby [Llama 2](https://ai.meta.com/llama/) model in pure C? No? Well, now you can!
-
-Train the Llama 2 LLM architecture in PyTorch then inference it with one simple 700-line C file ([run.c](run.c)). You might think that you need many billion parameter LLMs to do anything useful, but in fact very small LLMs can have surprisingly strong performance if you make the domain narrow enough (ref: [TinyStories](https://huggingface.co/datasets/roneneldan/TinyStories) paper). This repo is a "fullstack" train + inference solution for Llama 2 LLM, with focus on minimalism and simplicity.
+Have you ever wanted to inference a [Llama 3.2](https://www.llama.com/) model in pure C? No? Well, now you can!
 
-As the architecture is identical, you can also load and inference Meta's Llama 2 models. However, the current code only inferences models in fp32, so you will most likely not be able to productively load models larger than 7B. Work on model quantization is currently ongoing.
-
-Please note that this repo started recently as a fun weekend project: I took my earlier [nanoGPT](https://github.com/karpathy/nanoGPT), tuned it to implement the Llama-2 architecture instead of GPT-2, and the meat of it was writing the C inference engine in [run.c](run.c). So the project is young and moving quickly. Hat tip to the awesome [llama.cpp](https://github.com/ggerganov/llama.cpp) for inspiring this project. Compared to llama.cpp, I wanted something super simple, minimal, and educational so I chose to hard-code the Llama 2 architecture and just roll one inference file of pure C with no dependencies.
+Inference Llama 3.2 1B/3B with one simple 700-line C file ([run.c](run.c)). You might think that you need many billion parameter LLMs to do anything useful, but in fact very small LLMs can have surprisingly strong performance if you make the domain narrow enough (ref: [TinyStories](https://huggingface.co/datasets/roneneldan/TinyStories) paper). This repo is an inference solution for Llama3.2 family LLMs, with focus on minimalism and simplicity.
 
 ## feel the magic
-
-[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/karpathy/llama2.c/blob/master/run.ipynb)
-
 First, navigate to the folder where you keep your projects and clone this repository to this folder:
 
 ```bash
-git clone https://github.com/karpathy/llama2.c.git
+git clone https://github.com/Dylan-Harden3/llama3.2.c.git
 ```
 
 Then, open the repository folder:
@@ -28,227 +23,88 @@ Then, open the repository folder:
 cd llama2.c
 ```
 
-Now, let's just run a baby Llama 2 model in C. You need a model checkpoint. Download this 15M parameter model I trained on the [TinyStories](https://huggingface.co/datasets/roneneldan/TinyStories) dataset (~60MB download):
+The only prerequisites are gcc (or clang) and [PCRE](https://www.pcre.org/) - used for regex splitting in the new tokenizer (from scratch regex is outside the scope of this project).
+I installed PCRE with:
+```bash
+sudo apt install libpcre3 libpcre3-dev
+```
+
+Now, let's just run a Llama 3.2 model in C. You need a model checkpoint. Use [export.py](export.py) to load the models from huggingface. You need to apply for access and login with [huggingface cli](https://huggingface.co/docs/huggingface_hub/en/guides/cli).
 
 ```bash
-wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin
+python3 export.py Llama-3.2-1B.bin --hf meta-llama/Llama-3.2-1B
 ```
 
 Compile and run the C code:
 
 ```bash
 make run
-./run stories15M.bin
+./run Llama-3.2-1B.bin
 ```
 
-You'll see the text stream a sample. On my M1 MacBook Air this runs at ~110 tokens/s. See [performance](#performance) or the Makefile for compile flags that can significantly speed this up. We can also try a bit bigger 42M parameter model:
+You'll see the text stream a sample. On my machine this runs at ~9 tokens/s. See [performance](#performance) or the Makefile for compile flags that can significantly speed this up. We can also try a bit bigger 3B parameter model:
 
 ```bash
-wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin
-./run stories42M.bin
+python3 export.py Llama-3.2-3B.bin --hf meta-llama/Llama-3.2-1B
+./run Llama-3.2-3B.bin
 ```
 
-This still runs at interactive rates and samples more coherent and diverse stories:
-
-> Once upon a time, there was a little girl named Lily. She loved playing with her toys on top of her bed. One day, she decided to have a tea party with her stuffed animals. She poured some tea into a tiny teapot and put it on top of the teapot. Suddenly, her little brother Max came into the room and wanted to join the tea party too. Lily didn't want to share her tea and she told Max to go away. Max started to cry and Lily felt bad. She decided to yield her tea party to Max and they both shared the teapot. But then, something unexpected happened. The teapot started to shake and wiggle. Lily and Max were scared and didn't know what to do. Suddenly, the teapot started to fly towards the ceiling and landed on the top of the bed. Lily and Max were amazed and they hugged each other. They realized that sharing was much more fun than being selfish. From that day on, they always shared their tea parties and toys.
-
 You can also prompt the model with a prefix or a number of additional command line arguments, e.g. to sample at temperature 0.8 for 256 steps and with a prompt:
 
 ```bash
-./run stories42M.bin -t 0.8 -n 256 -i "One day, Lily met a Shoggoth"
+./run Llama-3.2-1B.bin -t 0.8 -n 256 -i "One day, Lily met a Shoggoth"
 ```
 
-> One day, Lily met a Shoggoth. He was very shy, but was also very generous. Lily said ÔÇ£Hello Shoggy! Can I be your friend?ÔÇØ Shoggy was happy to have a friend and said ÔÇ£Yes, letÔÇÖs explore the universe together!ÔÇØ So they set off on a journey to explore the universe. As they travelled, Shoggy was happy to explain to Lily about all the wonderful things in the universe. At the end of the day, Lily and Shoggy had gathered lots of wonderful things from the universe, and they both felt very proud. They promised to explore the universe as one big pair and to never stop being generous to each other.
-
-There is also an even better 110M param model available, see [models](#models).
-
 Quick note on sampling, the recommendation for ~best results is to sample with `-t 1.0 -p 0.9`, i.e. temperature 1.0 (default) but also top-p sampling at 0.9 (default). Intuitively, top-p ensures that tokens with tiny probabilities do not get sampled, so we can't get "unlucky" during sampling, and we are less likely to go "off the rails" afterwards. More generally, to control the diversity of samples use either the temperature (i.e. vary `-t` between 0 and 1 and keep top-p off with `-p 0`) or the top-p value (i.e. vary `-p` between 0 and 1 and keep `-t 1`), but not both. Nice explainers on LLM sampling strategies include [this](https://peterchng.com/blog/2023/05/02/token-selection-strategies-top-k-top-p-and-temperature/), [this](https://docs.cohere.com/docs/controlling-generation-with-top-k-top-p) or [this](https://huggingface.co/blog/how-to-generate).
 
-## Meta's Llama 2 models
-
-As the neural net architecture is identical, we can also inference the Llama 2 models released by Meta. Sadly there is a bit of friction here due to licensing (I can't directly upload the checkpoints, I think). So Step 1, get the Llama 2 checkpoints by following the [Meta instructions](https://github.com/facebookresearch/llama). Once we have those checkpoints, we have to convert them into the llama2.c format.
-For this we need to install the python dependencies (`pip install -r requirements.txt`) and then use the `export.py` file, e.g. for 7B model:
+You can also chat with the Llama 3.2 Instuction Tuned Chat models. Export the chat model exactly as above:
 
 ```bash
-python export.py llama2_7b.bin --meta-llama path/to/llama/model/7B
-```
-
-The export will take ~10 minutes or so and generate a 26GB file (the weights of the 7B model in float32) called `llama2_7b.bin` in the current directory. It has been [reported](https://github.com/karpathy/llama2.c/pull/85) that despite efforts. I would not attempt to run anything above 7B right now for two reasons: first, 13B+ currently doesn't work because of integer flow in pointer arithmetic, which is yet to be fixed, and second, even if it were fixed, this repo is doing float32 inference right now, so it would be fairly unusably slow. Once the export is done, we can run it:
-
-```bash
-./run llama2_7b.bin
-```
-
-This ran at about 4 tokens/s compiled with [OpenMP](#OpenMP) on 96 threads on my CPU Linux box in the cloud. (On my MacBook Air M1, currently it's closer to 30 seconds per token if you just build with `make runfast`.) Example output:
-
-> The purpose of this document is to highlight the state-of-the-art of CoO generation technologies, both recent developments and those in commercial use. The focus is on the technologies with the highest merit to become the dominating processes of the future and therefore to be technologies of interest to S&amp;T ... R&amp;D. As such, CoO generation technologies developed in Russia, Japan and Europe are described in some depth. The document starts with an introduction to cobalt oxides as complex products and a short view on cobalt as an essential material. The document continues with the discussion of the available CoO generation processes with respect to energy and capital consumption as well as to environmental damage.
-
-base models... ┬»\\_(Òâä)_/┬». Since we can inference the base model, it should be possible to also inference the chat model quite easily, and have a conversation with it. And if we can find a way to run 7B more efficiently, we can start adding LoRA to our training script, and going wild with finetunes all within the repo!
-
-You can also chat with the Llama Chat models. Export the chat model exactly as above:
-
-```bash
-python export.py llama2_7b_chat.bin --meta-llama /path/to/7B-chat
+python export.py Llama-3.2-1B-Instruct.bin --hf meta-llama/Llama-3.2-1B-Instruct
 ```
 
 Then chat with it by specifying the chat mode using the `-m` flag, e.g.:
 
 ```bash
-./run llama2_7b_chat.bin -m chat
-```
-
-You can also try Meta's Code Llama models even if support for them is incomplete. In particular, some hyperparameters changed (e.g. the constant in RoPE layer), so the inference is not exactly correct and a bit buggy right now. Looking into fixes. Make sure to build the tokenizer for the plain and instruct variants and pass it when doing inference.
-
-```bash
-python export.py codellama2_7b.bin --meta-llama /path/to/CodeLlama-7b
-python tokenizer.py --tokenizer-model=/path/to/CodeLlama-7b/tokenizer.model
-./run codellama2_7b.bin -z /path/to/CodeLlama-7b/tokenizer.bin
-```
-
-Chat with Code Llama Instruct:
-
-```bash
-python export.py codellama2_7b_instruct.bin --meta-llama /path/to/CodeLlama-7b-Instruct
-python tokenizer.py --tokenizer-model=/path/to/CodeLlama-7b-Instruct/tokenizer.model
-./run codellama2_7b_instruct.bin -m chat -z /path/to/CodeLlama-7b-Instruct/tokenizer.bin
+./run Llama-3.2-1B-Instruct.bin -m chat
 ```
 
 ## int8 quantization
 
 The (default) script [run.c](run.c), above, uses a float32 forward pass, where the entire calculation of the forward pass is kept in fp32. This is very easy to understand as far as reference code goes, but it has the following downsides: the model checkpoint files are very large (it takes 4 bytes per every individual weight), and the forward pass is relatively slow. The (very) common inference optimization employed in practice is to quantize the model parameters to lower precision, giving up a little bit of correctness in return for smaller checkpoint sizes and faster forward passes (as most of the inference uses integer arithmetic). Empirically, LLMs can tolerate precisions as low as 4-bit (or even lower), but we use int8 here because it is a "safe" setting that gets us the benefits but doesn't sacrifice too much of the model accuracy. Only the weights that participate in matmuls are quantized. All the other parameters (e.g. especially the scale and bias in RMSNorm) are kept in float32, because these layers are very sensitive. Now, if all you're after is reduction in checkpoint sizes, you could quantize the weights, save the checkpoint, and then dequantize them in run.c, and do float32 inference as normal and call it a day. This is totally fine. But here, we go one step further (as is standard practice) and additionally quantize the activations in the forward pass. This requires us to dynamically quantize and dequantize between float32 and int8 at runtime, which adds overhead. But the benefit is that now the majority of the calculations (the matmuls especially!) are using pure integer arithmetic, where both weights and activations enter as int8. This is where the speedups can fundamentally come from. The version we use is the "Q8_0" quantization (llama.cpp terminology), where the 0 means that the weight quantization is symmetric around 0, quantizing to the range [-127, 127].
 
-The quantized forward pass is implemented in [runq.c](runq.c). To use it, we have to export the model in the quantized format. For example, the float32 version of Llama 2 7B was exported as:
+The quantized forward pass is implemented in [runq.c](runq.c). To use it, we have to export the model in the quantized format. For example, the float32 version of Llama 3.2 1B was exported as:
 
 ```
-python export.py llama2_7b.bin --meta-llama path/to/llama/model/7B
+python export.py Llama-3.2-1B.bin --hf meta-llama/Llama-3.2-1B
 ```
 
-This creates a 26GB file, because each one of 7B parameters is 4 bytes (fp32). To export it quantized, we instead use version 2 export:
+This creates a 4.7GB file, because each one of 1B parameters is 4 bytes (fp32). To export it quantized, we instead use version 2 export:
 
 ```
-python export.py llama2_7b_q80.bin --version 2 --meta-llama path/to/llama/model/7B
+python export.py Llama-3.2-1B-q8_0.bin --version 2 --hf meta-llama/Llama-3.2-1B
 ```
 
-This runs for a few minutes, but now creates only a 6.7GB file. For exporting non-meta checkpoints you would use the --checkpoint arg instead of --meta-llama arg (more docs on this later, below). Now let's inference them. I like to use OMP here because these are big models, so e.g. on my Linux box:
+This runs for a few minutes, but now creates only a 1.3GB file. Now let's inference them. I like to use OMP here because these are big models, so e.g. on my machine:
 
 ```
 make runomp
-OMP_NUM_THREADS=64 ./run llama2_7b.bin -n 40
-OMP_NUM_THREADS=64 ./runq llama2_7b_q80.bin -n 40
+OMP_NUM_THREADS=6 ./run Llama-3.2-1B.bin -n 40
+OMP_NUM_THREADS=6 ./runq Llama-3.2-1B-q8_0.bin -n 40
 ```
 
-This runs 40 steps just to get a timing. The float32 version for me runs at 4.6 tok/s, and the int8 version at 14 tok/s. So we achieved a 3X speedup while reducing the checkpoint size by 4X. However, the forward pass is quantized to int8, and therefore silently very slightly lower quality.
+This runs 40 steps just to get a timing. The float32 version for me runs at 9 tok/s, and the int8 version at 26 tok/s. So we achieved a 3X speedup while reducing the checkpoint size by 4X. However, the forward pass is quantized to int8, and therefore silently very slightly lower quality.
 
 ## huggingface models
 
-We can load any huggingface models that use the Llama 2 architecture. See the script [export.py](export.py) and the `--hf` flag to export the model .bin file.
-
-## models
-
-For the sake of examples of smaller, from-scratch models, I trained a small model series on TinyStories. All of these trained in a few hours on my training setup (4X A100 40GB GPUs). The 110M took around 24 hours. I am hosting them on huggingface hub [tinyllamas](https://huggingface.co/karpathy/tinyllamas), both in the original PyTorch .pt, and also in the llama2.c format .bin:
-
-| model | dim | n_layers | n_heads | n_kv_heads | max context length | parameters | val loss | download
-| --- | --- | --- | --- | --- | --- | --- | --- | --- |
-| 260K | 64 | 5 | 8 | 4 | 512 | 260K | 1.297 | [stories260K](https://huggingface.co/karpathy/tinyllamas/tree/main/stories260K)
-| OG | 288 | 6 | 6 | 6 | 256 | 15M | 1.072 | [stories15M.bin](https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin) |
-| 42M| 512 | 8 | 8 | 8 | 1024 | 42M | 0.847 | [stories42M.bin](https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin) |
-| 110M| 768 | 12 | 12 | 12 | 1024 | 110M | 0.760 | [stories110M.bin](https://huggingface.co/karpathy/tinyllamas/resolve/main/stories110M.bin) |
-
-You'll notice that the 110M model is equivalent to GPT-1 in size. Alternatively, this is also the smallest model in the GPT-2 series (`GPT-2 small`), except the max context length is only 1024 instead of 2048. The only notable changes from GPT-1/2 architecture is that Llama uses RoPE relatively positional embeddings instead of absolute/learned positional embeddings, a bit more fancy SwiGLU non-linearity in the MLP, RMSNorm instead of LayerNorm, bias=False on all Linear layers, and is optionally multiquery.
-
-## training
-
-Let's see how we can train a baby Llama 2 from scratch using the code in this repo. First let's download and pretokenize some source dataset, e.g. I like [TinyStories](https://huggingface.co/datasets/roneneldan/TinyStories) so this is the only example currently available in this repo. But it should be very easy to add datasets, see the code.
-
-```bash
-python tinystories.py download
-python tinystories.py pretokenize
-```
-
-Then train our model:
-
-```bash
-python train.py
-```
-
-**brief training guide**. See the train.py script for more exotic launches and hyperparameter overrides. Here is a brief guide to how to set the parameters. Look at the table at the very end of the [Chinchilla paper](https://arxiv.org/abs/2203.15556) to get a sense of how the Transformer parameters (dim, n_layers, n_heads) grow or shrink together. Extrapolate/interpolate this pattern to get bigger or smaller transformers. Set the max context length however you wish, depending on the problem: this should be the max number of tokens that matter to predict the next token. E.g. Llama 2 uses 2048. Next, you want the _total_ batch size per update (printed by the script as "tokens per iteration will be:") to be somewhere around 100K tokens for medium-sized applications. For tiny applications it could be lower, for large training (e.g. GPTs/LLamas) it is usually ~0.5M, or even more. You get there by first maxing out the batch_size to whatever your system allows (e.g. mine was 16 in a recent run because after that my GPU runs out of memory), and then you want to increase gradient_accumulation_steps to be as high as necessary to reach the total batch size of ~100K. Finally, you want to tune your learning_rate (LR). You want this to be as high as your training allows. Very small networks can get away with a large LR (e.g. 1e-3 or even higher). Large networks need lower LRs. 3e-4 is a safe choice in most medium-sized applications, but can be too low for small networks, so try to increase it! Finally, max_iters is the length of training. Play with different settings. I mostly only ever tune these parameters and leave most of the others unchanged. Here is an example of how I trained the 110M model, which I don't think is anywhere near optimal, but looked sensible to me: dim 768, n_layers 12, n_heads 12 (so size of each head is 768 / 12 = 64 channels), seq len of 1024, batch size 16 (this is the most that fit my A100 40GB GPU), gradient_accumulation_steps = 8 was needed to get total tokens batch size to be 16 batch size * 1024 tokens in sequence * 8 grad_accum = 131,072 tokens per update. Good. Learning rate 4e-4 (probably a little too low). max_iters 200K (probably a bit too high). Dropout 0.1, as that usually helps a bit at medium size. That was it. I ran using Distributed Data Parallel (DDP) on 4 GPUs on my cloud machine, training took ~day or so.
-
-Totally understand if you want to skip model training, for simple demo just download one of the pretrained models (see [models](#models) section), e.g.:
-
-```bash
-wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin
-```
-
-Once we have the model.bin file, we can inference in C. Compile the C code first:
-
-```bash
-make run
-```
-
-You can now run it simply as
-
-```bash
-./run stories15M.bin
-```
-
-Watch the tokens stream by, fun! We can also run the PyTorch inference script for a comparison. Download one of the models again from huggingface hub and point the `sample.py` script at it:
-
-```bash
-wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.pt -P out15M
-python sample.py --checkpoint=out15M/stories15M.pt
-```
-
-Which gives the same results.
-
-## custom tokenizers
-
-In everything above, we've assumed the custom Lllama 2 tokenizer with 32,000 tokens. However, in many boutique LLMs, using vocabulary this big might be an overkill. If you have a small application you have in mind, you might be much better off training your own tokenizers. This can make everything nicer - with smaller vocabs your model has fewer parameters (because the token embedding table is a lot smaller), the inference is faster (because there are fewer tokens to predict), and your average sequence length per example could also get smaller (because the compression is a lot more efficient on your data). So let's see how we train a custom tokenizer.
-
-By default, to pretokenize the tinystories dataset we had to run, in order:
-
-```
-python tinystories.py download
-python tinystories.py pretokenize
-```
-
-The `pretokenize` stage here loads the Llama 2 tokenizer (vocab size 32,000) and uses it to convert the downloaded text into integers, and saves that to file. We now change this as follows, to train an example 4096-token tokenizer:
-
-```
-python tinystories.py download
-python tinystories.py train_vocab --vocab_size=4096
-python tinystories.py pretokenize --vocab_size=4096
-```
-
-The `train_vocab` stage will call the `sentencepiece` library to train the tokenizer, storing it in a new file `data/tok4096.model`. I tried to reproduce as well as I could the settings that (I think) Meta used to train their vocabulary. This uses the Byte Pair Encoding algorithm that starts out with raw utf8 byte sequences of the text data and then iteratively merges the most common consecutive pairs of tokens to form the vocabulary. Inspect the `tinystories.py` file - the custom tokenizers are stored in a special directory structure indexed by the vocab size.
-
-A quick note of interest is that vocab size of 4096 trained specifically on tinystories creates integer sequences with about the same sequence length per example as the default Llama 2 tokenizer of 32000 tokens! This means that our custom, tailored tokenizer is a lot better adapted to our specific text, and can compress it very effectively. So our trained models are smaller and faster.
-
-Now that we have pretokenized the dataset with our custom tokenizer, we can train the model. The training script `train.py` doesn't care about the exact tokens, it only cares about the vocabulary size so it can correctly initialize the model. So when training your model, make sure to pass in
-
-```
-python train.py --vocab_source=custom --vocab_size=4096
-```
-
-(The defaults are `llama2` and `32000` respectively, which indicates the default Llama 2 tokenizer). This trains the model. Finally we are ready to run inference with our `run.c` script. For that we need two things. Number one, we have to export our tokenizer in the `.bin` format, do that with:
-
-```
-python tokenizer.py --tokenizer-model=data/tok4096.model
-```
-
-This writes the tokenizer to `data/tok4096.bin`. Now we can run inference, pointing it to this tokenizer using the `-z` flag:
-
-```
-./run out/model.bin -z data/tok4096.bin
-```
-
-This should print the samples. If you leave out the `-z` flag, it will use the default Llama 2 tokenizer, which would generate a good sequence of integers, but they would get translated using a different vocabulary to text, so it would look like gibberish.
+We can load any huggingface models that use the Llama 3.2 architecture. See the script [export.py](export.py) and the `--hf` flag to export the model .bin file.
 
 ## performance
 
 There are many ways to potentially speed up this code depending on your system. Have a look at the [Makefile](Makefile), which contains a lot of notes. The `make run` command currently uses the `-O3` optimization by default, i.e.:
 
 ```bash
-gcc -O3 -o run run.c -lm
+gcc -O3 -o run run.c -lm -lpcre
 ```
 
 -O3 includes optimizations that are expensive in terms of compile time and memory usage. Including vectorization, loop unrolling, and predicting branches.
@@ -257,7 +113,7 @@ To get a much better performance, try to compile with `make runfast`. This turns
 
 Try `-march=native` to compile the program to use the architecture of the machine you're compiling on rather than a more generic CPU. This may enable additional optimizations and hardware-specific tuning such as improved vector instructions/width.
 
-The fastest throughput I saw so far on my MacBook Air (M1) so far is with `make runfast`.
+The fastest throughput I saw so far on my machine so far is with `make runomp`.
 
 You can also experiment with replacing `gcc` with `clang`.
 
@@ -267,7 +123,7 @@ If compiling with gcc, try experimenting with `-funroll-all-loops`, see PR [#183
 You'll need to install the OpenMP library and the clang compiler first (e.g. `apt install clang libomp-dev` on ubuntu). Then you can compile with `make runomp`, which does:
 
 ```bash
-clang -Ofast -fopenmp -march=native run.c  -lm  -o run
+clang -Ofast -fopenmp -march=native run.c  -lm -lpcre  -o run
 ```
 
 When you run inference make sure to use OpenMP flags to set the number of threads, e.g.:
@@ -279,137 +135,6 @@ OMP_NUM_THREADS=4 ./run out/model.bin
 Depending on your system resources you may want to tweak these hyperparameters and use more threads. But more is not always better, usually this is a bit U shaped. In particular, if your CPU has SMT (multithreading), try setting the number of threads to the number of physical cores rather than logical cores. The performance difference can be large due to cache thrashing and communication overhead. The PyTorch documentation [CPU specific optimizations
 ](https://pytorch.org/tutorials/recipes/recipes/tuning_guide.html#cpu-specific-optimizations) has some good information that applies here too.
 
-## platforms
-
-On **Windows**, use `build_msvc.bat` in a Visual Studio Command Prompt to build with msvc, or you can use `make win64` to use mingw compiler toolchain from linux or windows to build the windows target. MSVC build will automatically use openmp and max threads appropriate for your CPU unless you set `OMP_NUM_THREADS` env.
-
-On **Centos 7**, **Amazon Linux 2018** use `rungnu` Makefile target: `make rungnu` or `make runompgnu` to use openmp.
-
-On **Mac**, use clang from brew for openmp build. Install clang as `brew install llvm` and use the installed clang binary to compile with openmp: `make runomp CC=/opt/homebrew/opt/llvm/bin/clang`
-
-## tests
-
-You can run tests simply with pytest:
-
-```bash
-$ pip install pytest
-$ pytest
-```
-
-This will currently invoke two tests inside `test_all.py`, which forward the model in both C and Python for 200 steps and check the output against a known good expected output. The tests currently run in only a few seconds, but will have to download and cache the stories260K models in a temporary `test` directory (only ~2MB download).
-
-There are also some tests in C, in the file [test.c](test.c). You can run these with `make testcc`, or to see more stuff printed:
-
-```
-make testcc VERBOSITY=1
-```
-
-Call for help: help add more tests.
-
-## ack
-
-I trained the llama2.c storyteller models on a 4X A100 40GB box graciously provided by the excellent [Lambda labs](https://lambdalabs.com/service/gpu-cloud), thank you.
-
-## discord
-
-Figured it's possible to reuse my existing discord channel (that I use for my [zero to hero youtube series](https://karpathy.ai/zero-to-hero.html)), see #llama2c channel on [discord](https://discord.gg/3zy8kqD9Cp), for any quick questions, related discussions, etc.
-
-## contributing
-
-A few words on this repo and the kinds of PRs that are likely to be accepted. What is the goal of this repo? Basically I think there will be a lot of interest in training or finetuning custom micro-LLMs (think ~100M - ~1B params, but let's say up to ~10B params) across a large diversity of applications, and deploying them in edge-adjacent environments (think MCUs, phones, web browsers, laptops, etc.). I'd like this repo to be the simplest, smallest, most hackable repo to support this workflow, both training and inference. In particular, this repo is not a complex framework with a 1000 knobs controlling inscrutible code across a nested directory structure of hundreds of files. Instead, I expect most applications will wish to create a fork of this repo and hack it to their specific needs and deployment platforms.
-
-People who care about deployment efficiency above all else should look at [llama.cpp](https://github.com/ggerganov/llama.cpp). This repo still cares about efficiency, but not at the cost of simplicity, readability or portability. Basically, I expect that a lot of people come to this repo because the training code is 2 readable .py files and the inference code is 500 lines of C. So I'd like this to continue to be a kind of simplest "reference implementation" that can be easily hacked in a separate fork into whatever downstream application people are excited about. It shouldn't be full-featured. It shouldn't take 100 different options or settings. It shouldn't be the most efficient. A few examples:
-
-- someone re-ordered two loops to improve data locality for a small efficieny win => instant merge.
-- someone added the one line "pragma omp parallel for", which allows you to compile with OpenMP and dramatically speed up the code, or acts as just a comment if you don't compile it that way => instant merge.
-- bug fixes and touchups etc. => happy to merge
-
-A few examples of PRs are that are not an excellent fit:
-
-- adding more than several #ifdefs all over the place in code. If they are localized / few, might be okay.
-- adding a lot of code that is very specific to some specific platform (e.g. MCUs, or some special version of linux or processor). These may be a better fit for forks of the project, and I am very happy to maintain a list of these forks in section below.
-- adding hundreds of lines of code to run.c that are only active in specific scenarios or platforms.
-
-If your candidate PRs have elements of these it doesn't mean they won't get merged, it just means they will make it into the gray territory. TLDR: I am eager to merge any mostly small, mostly localized, broadly applicable, clean changes that improve the efficiency and portability of the repo, while keep its hackability and readability. I appreciate all PRs seeking to help me improve the project, thank you! <3.
-
-## notable forks
-
-- Rust
-  - [llama2.rs](https://github.com/gaxler/llama2.rs) by @[gaxler](https://github.com/gaxler): a Rust port of this project
-  - [llama2.rs](https://github.com/leo-du/llama2.rs) by @[leo-du](https://github.com/leo-du): A Rust port of this project
-  - [llama2-rs](https://github.com/danielgrittner/llama2-rs) by @[danielgrittner](https://github.com/danielgrittner): a Rust port of this project
-  - [llama2.rs](https://github.com/lintian06/llama2.rs) by @[lintian06](https://github.com/lintian06): A Rust port of this project
-  - [pecca.rs](https://github.com/rahoua/pecca-rs) by @[rahoua](https://github.com/rahoua): A Rust port leveraging [ndarray](https://github.com/rust-ndarray/ndarray), supports BLAS.
-  - [llama2.rs](https://github.com/flaneur2020/llama2.rs) by @[flaneur2020](https://github.com/flaneur2020): A Rust port of this project.
-  - [llama2-burn](https://github.com/code-cp/llama2-burn): A Rust port of this project leveraging [Burn](https://github.com/tracel-ai/burn)
-- Go
-  - [go-llama2](https://github.com/tmc/go-llama2) by @[tmc](https://github.com/tmc): a Go port of this project
-  - [llama2.go](https://github.com/nikolaydubina/llama2.go) by @[nikolaydubina](https://github.com/nikolaydubina): a Go port of this project
-  - [llama2.go](https://github.com/haormj/llama2.go) by @[haormj](https://github.com/haormj): a Go port of this project
-  - [llama2.go](https://github.com/saracen/llama2.go) by @[saracen](https://github.com/saracen): a Go port of this project
-- Android
-  - [llama2.c-android](https://github.com/Manuel030/llama2.c-android): by @[Manuel030](https://github.com/Manuel030): adds Android binaries of this project
-  - [llama2.c-android-wrapper](https://github.com/celikin/llama2.c-android-wrapper): by @[celikin](https://github.com/celikin): added JNI wrapper, PoC
-- C
-  - [llama3.c](https://github.com/jameswdelancey/llama3.c): by @[jameswdelancey](https://github.com/jameswdelancey): a LLaMA 3 8B Base and Instruct port of this project
-- C++
-  - [llama2.cpp](https://github.com/leloykun/llama2.cpp) by @[leloykun](https://github.com/leloykun): a C++ port of this project
-  - [llama2.cpp](https://github.com/coldlarry/llama2.cpp) by @[coldlarry](https://github.com/coldlarry): a C++ port of this project
-- JavaScript
-  - [llama2.js](https://github.com/epicure/llama2.js) by @[epicure](https://github.com/epicure): a JavaScript port of this project
-  - [llamajs](https://github.com/agershun/llamajs) by @[agershun](https://github.com/agershun): a JavaScript port of this project
-  - [llama2.ts](https://github.com/wizzard0/llama2.ts) by @[oleksandr_now](https://twitter.com/oleksandr_now): a TypeScript port of this project. Full Llama2-7B capable.
-  - [llama2.c-emscripten](https://github.com/gohai/llama2.c-emscripten) by @[gohai](https://github.com/gohai): Emscripten (JavaScript) port, based on @ggerganov's initial prototype
-- Zig
-  - [llama2.zig](https://github.com/cgbur/llama2.zig) by @[cgbur](https://github.com/cgbur): A Zig port of this project
-  - [llama2.zig](https://github.com/vodkaslime/llama2.zig) by @[vodkaslime](https://github.com/vodkaslime): a Zig port of this project
-  - [llama2.zig](https://github.com/clebert/llama2.zig) by @[clebert](https://github.com/clebert): a Zig port of this project
-- Julia
-  - [llama2.jl](https://github.com/juvi21/llama2.jl) by @[juvi21](https://github.com/juvi21): a Julia port of this project
-- Scala
-  - [llama2.scala](https://github.com/jrudolph/llama2.scala) by @[jrudolph](https://github.com/jrudolph): a Scala port of this project
-- Java
-  - [llama2.java](https://github.com/mukel/llama2.java) by @[mukel](https://github.com/mukel): a Java port of this project
-  - [llama2.java](https://github.com/neoremind/llama2.java) by @[neoremind](https://github.com/neoremind): a Java port of this project
-  - [llama2.tornadovm.java](https://github.com/mikepapadim/llama2.tornadovm.java) by @[mikepapadim](https://github.com/mikepapadim): an extension of the llama2.java with GPU-support through [TornadoVM](https://github.com/beehive-lab/TornadoVM).
-- Kotlin
-  - [llama2.kt](https://github.com/madroidmaq/llama2.kt) by @[madroidmaq](https://github.com/madroidmaq): a Kotlin port of this project
-  - [llama2-kmp](https://github.com/stepango/llama2-kmp) by @[stepango](https://github.com/stepango): a Kotlin multiplatform(KMP) port of this project 
-- Python
-  - [llama2.py](https://github.com/tairov/llama2.py) by @[tairov](https://github.com/tairov): a simple one file pure Python port of this project with zero dependencies
-- C#
-  - [llama2.cs](https://github.com/trrahul/llama2.cs) by @[trrahul](https://github.com/trrahul): a C# port of this project
-- F#
-  - [llama2.fs](https://github.com/micsh/llama2.fs) by @[micsh](https://github.com/micsh): a F# port of this project
-- Dart
-  - [llama2.dart](https://github.com/yiminghan/llama2.dart) by @[yiminghan](https://github.com/yiminghan/llama2.dart): one-file dart port of this project, works with Flutter!
-- Web
-  - [llama2c-web](https://github.com/dmarcos/llama2.c-web) by @[dmarcos](https://github.com/dmarcos): Super simple way to build unmodified llama2.c to WASM and run it in the browser. [Demo](https://diegomarcos.com/llama2.c-web/)
-  - [llama2.rs.wasm](https://github.com/mtb0x1/llama2.rs.wasm) by @[mtb0x1](https://github.com/mtb0x1/) : a [Demo](https://mtb0x1.github.io/llama2.rs.wasm/) of all listed rust ports to WASM, all in one web page.
-- WebAssembly
-  - [icpp-llm](https://github.com/icppWorld/icpp-llm): LLMs for the Internet Computer
-- Fortran
-  - [llama2.f90](https://github.com/rbitr/llama2.f90): a Fortran port of this project
-- Mojo
-  - [llama2.­ƒöÑ](https://github.com/tairov/llama2.mojo) by @[tairov](https://github.com/tairov): pure Mojo port of this project
-- OCaml
-  - [llama2.ml](https://github.com/jackpeck/llama2.ml) by @[jackpeck](https://github.com/jackpeck): an OCaml port of this project
-- Hare
-  - [llama2.ha](https://sr.ht/~dvshkn/llama2.ha) by @[dvshkn](https://git.sr.ht/~dvshkn): a Hare port of this project
-- [llama2.c - Llama 2 Everywhere](https://github.com/trholding/llama2.c) by @[trholding](https://github.com/trholding): Standalone, Bootable & Portable Binary Llama 2
-- [llama2.c-zh - Bilingual Chinese and English](https://github.com/chenyangMl/llama2.c-zh) by @[chenyangMl](https://github.com/chenyangMl): Expand tokenizer to support training and inference in both Chinese and English
-- Haskell
-  - [llama2.hs](https://github.com/chris-ch/llama2.hs) by @[chris-ch](https://github.com/chris-ch): an Haskell port of this project
-
-## unsorted todos
-
-- add support in run.c of reading version 1+ files from export, later deprecate "version 0"
-- run.cu (CUDA) investigate and merge
-- add more tests inside [test.c](test.c)
-- add Engine class for use in sample.py that does efficient inference in PyTorch, e.g. KV cache keeping
-- make it easier to add a new dataset with not too much pain
-- (LoRA) finetuning and export of Llama 2 models
-
 ## License
 
 MIT
diff --git a/export.py b/export.py
index 08b13be..2f9e450 100644
--- a/export.py
+++ b/export.py
@@ -452,7 +452,7 @@ def load_hf_model(model_path):
     config.dim = hf_model.config.hidden_size
     config.n_layers = hf_model.config.num_hidden_layers
     config.n_heads = hf_model.config.num_attention_heads
-    config.n_kv_heads = hf_model.config.num_attention_heads
+    config.n_kv_heads = hf_model.config.num_key_value_heads
     config.vocab_size = hf_model.config.vocab_size
     config.hidden_dim = hf_model.config.intermediate_size
     config.norm_eps = hf_model.config.rms_norm_eps
@@ -472,7 +472,8 @@ def load_hf_model(model_path):
         i = layer.layer_id
         layer.attention_norm.weight = nn.Parameter(hf_dict[f'model.layers.{i}.input_layernorm.weight'])
         layer.attention.wq.weight = nn.Parameter(permute_reverse(hf_dict[f'model.layers.{i}.self_attn.q_proj.weight']))
-        layer.attention.wk.weight = nn.Parameter(permute_reverse(hf_dict[f'model.layers.{i}.self_attn.k_proj.weight']))
+        k_proj = hf_dict[f'model.layers.{i}.self_attn.k_proj.weight']
+        layer.attention.wk.weight = nn.Parameter(permute_reverse(k_proj, n_heads=config.n_kv_heads, dim1=k_proj.shape[0], dim2=k_proj.shape[1]))
         layer.attention.wv.weight = nn.Parameter(hf_dict[f'model.layers.{i}.self_attn.v_proj.weight'])
         layer.attention.wo.weight = nn.Parameter(hf_dict[f'model.layers.{i}.self_attn.o_proj.weight'])
         layer.ffn_norm.weight = nn.Parameter(hf_dict[f'model.layers.{i}.post_attention_layernorm.weight'])
diff --git a/requirements.txt b/requirements.txt
index 7187a73..e89efc5 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -5,3 +5,4 @@ sentencepiece==0.1.99
 torch==2.0.1
 tqdm==4.64.1
 wandb==0.15.5
+tiktoken==0.8.0
\ No newline at end of file
diff --git a/run.c b/run.c
index 2fcd687..d5f2a2c 100644
--- a/run.c
+++ b/run.c
@@ -7,6 +7,7 @@
 #include <math.h>
 #include <string.h>
 #include <fcntl.h>
+#include <pcre.h> // for regex splits in tokenizer
 #if defined _WIN32
     #include "win.h"
 #else
@@ -264,7 +265,7 @@ float* forward(Transformer* transformer, int token, int pos) {
         // RoPE relative positional encoding: complex-valued rotate q and k in each head
         for (int i = 0; i < dim; i+=2) {
             int head_dim = i % head_size;
-            float freq = 1.0f / powf(10000.0f, head_dim / (float)head_size);
+            float freq = 1.0f / powf(500000.0f, head_dim / (float)head_size);
             float val = pos * freq;
             float fcr = cosf(val);
             float fci = sinf(val);
@@ -417,8 +418,8 @@ void free_tokenizer(Tokenizer* t) {
 
 char* decode(Tokenizer* t, int prev_token, int token) {
     char *piece = t->vocab[token];
-    // following BOS (1) token, sentencepiece decoder strips any leading whitespace (see PR #89)
-    if (prev_token == 1 && piece[0] == ' ') { piece++; }
+    // following BOS (128000) token, sentencepiece decoder strips any leading whitespace (see PR #89)
+    if (prev_token == 128000 && piece[0] == ' ') { piece++; }
     // careful, some tokens designate raw bytes, and look like e.g. '<0x01>'
     // parse this and convert and return the actual byte
     unsigned char byte_val;
@@ -472,102 +473,166 @@ void encode(Tokenizer* t, char *text, int8_t bos, int8_t eos, int *tokens, int *
     // start at 0 tokens
     *n_tokens = 0;
 
-    // add optional BOS (=1) token, if desired
-    if (bos) tokens[(*n_tokens)++] = 1;
+    // add optional BOS (=128000) token, if desired
+    if (bos) tokens[(*n_tokens)++] = 128000;
 
-    // add_dummy_prefix is true by default
-    // so prepend a dummy prefix token to the input string, but only if text != ""
-    // TODO: pretty sure this isn't correct in the general case but I don't have the
-    // energy to read more of the sentencepiece code to figure out what it's doing
-    if (text[0] != '\0') {
-        int dummy_prefix = str_lookup(" ", t->sorted_vocab, t->vocab_size);
-        tokens[(*n_tokens)++] = dummy_prefix;
+    // regex to force splits from the Meta Llama 3 repo (https://github.com/meta-llama/llama3/blob/main/llama/tokenizer.py): 
+    const char* normal_regex = "(?i:'s|'t|'re|'ve|'m|'ll|'d)|[^\r\n\\p{L}\\p{N}]?\\p{L}+|\\p{N}{1,3}| ?[^\\s\\p{L}\\p{N}]+[\r\n]*|\\s*[\r\n]+|\\s+(?!\\S)|\\s+";
+    // regex for special tokens ex. <|eot_id|>, <|start_header_id|> etc
+    // in the tiktoken code its just all of the specail tokens "or"ed together (https://github.com/openai/tiktoken/blob/main/src/lib.rs#L441)
+    // TODO: add this in tokenizer export
+    const char *special_regex = "<\\|begin_of_text\\|>|<\\|end_of_text\\|>|<\\|start_header_id\\|>|<\\|end_header_id\\|>|<\\|eot_id\\|>|<\\|reserved_special_token_([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|250)\\|>";
+
+    const char *error;
+    int erroffset;
+    pcre *re_special = pcre_compile(special_regex, 0, &error, &erroffset, NULL);
+    pcre *re_normal = pcre_compile(normal_regex, PCRE_UTF8 | PCRE_UCP | PCRE_CASELESS, &error, &erroffset, NULL);
+
+    if (re_special == NULL || re_normal == NULL) {
+        fprintf(stderr, "Failed to compile regex: %s\n", error);
+        exit(EXIT_FAILURE);
     }
 
-    // Okay UTF-8 time. This will get messy. Here is the reference from Wikipedia:
-    // Code point Ôåö UTF-8 conversion
-    // First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
-    // U+0000	U+007F	    0xxxxxxx
-    // U+0080	U+07FF	    110xxxxx	10xxxxxx
-    // U+0800	U+FFFF	    1110xxxx	10xxxxxx	10xxxxxx
-    // U+10000	U+10FFFF    11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
-
-    // process the raw (UTF-8) byte sequence of the input string
-    for (char *c = text; *c != '\0'; c++) {
-
-        // reset buffer if the current byte is ASCII or a leading byte
-        // 0xC0 is 11000000, so (*c & 0xC0) keeps the first 2 bits and zeros the rest
-        // 0x80 is 10000000
-        // in UTF-8, all continuation bytes start with "10" in first two bits
-        // so in English this is: "if this byte is not a continuation byte"
-        if ((*c & 0xC0) != 0x80) {
-            // this byte must be either a leading byte (11...) or an ASCII char (0x...)
-            // => reset our location, as we're starting a new UTF-8 codepoint
-            str_len = 0;
-        }
+    size_t idx = 0;
+    size_t text_len = strlen(text);
 
-        // append the current byte to the buffer
-        str_buffer[str_len++] = *c; // ++ is post-increment, incremented after this line
-        str_buffer[str_len] = '\0';
+    // inspired from the tiktoken code: https://github.com/openai/tiktoken/blob/main/src/lib.rs#L216
+    while (idx < text_len) {
+        int ovector[512];
+        int special_match = pcre_exec(re_special, NULL, text + idx, text_len - idx, 0, 0, ovector, 512);
+        int special_match_len = ovector[1] - ovector[0];
 
-        // while the next character is a continuation byte, continue appending
-        // but if there are too many of them, just stop to avoid overruning str_buffer size.
-        if ((*(c+1) & 0xC0) == 0x80 && str_len < 4) {
-            continue;
-        }
+        size_t end = (special_match >= 0) ? idx + ovector[0] : text_len;
 
-        // ok c+1 is not a continuation byte, so we've read in a full codepoint
-        int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
+        // proces the tokens up to the start of the next special token, or end if there is none
+        while (idx < end) {
+            int normal_match = pcre_exec(re_normal, NULL, text + idx, end - idx, 0, 0, ovector, 512);
+            if (normal_match < 0) break;
 
-        if (id != -1) {
-            // we found this codepoint in vocab, add it as a token
-            tokens[(*n_tokens)++] = id;
-        } else {
-            // byte_fallback encoding: just encode each byte as a token
-            // +3 is here because the first 3 vocab elements are <unk>, <s>, </s>
-            // so the individual bytes only start at index 3
-            for (int i=0; i < str_len; i++) {
-                tokens[(*n_tokens)++] = (unsigned char)str_buffer[i] + 3;
-            }
-        }
-        str_len = 0; // protect against a sequence of stray UTF8 continuation bytes
-    }
+            size_t normal_match_len = ovector[1] - ovector[0];
+            char matched_str[normal_match_len+1];
+            strncpy(matched_str, text + idx, normal_match_len);
+            matched_str[normal_match_len] = '\0';
+
+            int token_id = str_lookup(matched_str, t->sorted_vocab, t->vocab_size);
+
+            // if the split already forms a token, dont run BPE and just use it
+            if (token_id != -1) {
+                tokens[(*n_tokens)++] = token_id;
+            } else {
+                // BPE
+                int split_tokens[1024];
+                int split_n_tokens = 0;
+                char* sequence = matched_str;
+
+                strcpy(str_buffer, sequence);
+
+                // Okay UTF-8 time. This will get messy. Here is the reference from Wikipedia:
+                // Code point Ôåö UTF-8 conversion
+                // First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
+                // U+0000	U+007F	    0xxxxxxx
+                // U+0080	U+07FF	    110xxxxx	10xxxxxx
+                // U+0800	U+FFFF	    1110xxxx	10xxxxxx	10xxxxxx
+                // U+10000	U+10FFFF    11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
+                // process the raw (UTF-8) byte sequence of the input string
+                size_t str_len = 0;
+                for (char *c = sequence; *c != '\0'; c++) {
+                    // reset buffer if the current byte is ASCII or a leading byte
+                    // 0xC0 is 11000000, so (*c & 0xC0) keeps the first 2 bits and zeros the rest
+                    // 0x80 is 10000000
+                    // in UTF-8, all continuation bytes start with "10" in first two bits
+                    // so in English this is: "if this byte is not a continuation byte"
+                    if ((*c & 0xC0) != 0x80) {
+                        // this byte must be either a leading byte (11...) or an ASCII char (0x...)
+                        // => reset our location, as we're starting a new UTF-8 codepoint
+                        str_len = 0;
+                    }
+
+                    // append the current byte to the buffer
+                    str_buffer[str_len++] = *c; // ++ is post-increment, incremented after this line
+                    str_buffer[str_len] = '\0';
+
+                    // while the next character is a continuation byte, continue appending
+                    // but if there are too many of them, just stop to avoid overruning str_buffer size.
+                    if ((*(c+1) & 0xC0) == 0x80 && str_len < 4) {
+                        continue;
+                    }
+                    // ok c+1 is not a continuation byte, so we've read in a full codepoint
+                    int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
+                    if (id != -1) {
+                        // we found this codepoint in vocab, add it as a token
+                        split_tokens[split_n_tokens++] = id;
+                    } else {
+                        // byte_fallback encoding: just encode each byte as a token
+                        for (int j=0; j < str_len; j++) {
+                            split_tokens[split_n_tokens++] = (unsigned char)str_buffer[j];
+                        }
+                    }
+                    str_len = 0; // protect against a sequence of stray UTF8 continuation bytes
+                }
 
-    // merge the best consecutive pair each iteration, according the scores in vocab_scores
-    while (1) {
-        float best_score = -1e10;
-        int best_id = -1;
-        int best_idx = -1;
-
-        for (int i=0; i < (*n_tokens-1); i++) {
-            // check if we can merge the pair (tokens[i], tokens[i+1])
-            sprintf(str_buffer, "%s%s", t->vocab[tokens[i]], t->vocab[tokens[i+1]]);
-            int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
-            if (id != -1 && t->vocab_scores[id] > best_score) {
-                // this merge pair exists in vocab! record its score and position
-                best_score = t->vocab_scores[id];
-                best_id = id;
-                best_idx = i;
+                // merge the best consecutive pair each iteration, according the scores in vocab_scores
+                while (1) {
+                    float best_score = 1e10;
+                    int best_id = -1;
+                    int best_idx = -1;
+
+                    for (int j = 0; j < split_n_tokens - 1; j++) {
+                        // check if we can merge the pair (tokens[i], tokens[i+1])
+                        sprintf(str_buffer, "%s%s", t->vocab[split_tokens[j]], t->vocab[split_tokens[j + 1]]);
+                        int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
+
+                        if (id != -1 && t->vocab_scores[id] < best_score) {
+                            // this merge pair exists in vocab! record its score and position
+                            best_score = t->vocab_scores[id];
+                            best_id = id;
+                            best_idx = j;
+                        }
+                    }
+
+                    if (best_idx == -1) {
+                        break; // we couldn't find any more pairs to merge, so we're done
+                    }
+
+                    // merge the consecutive pair (best_idx, best_idx+1) into new token best_id
+                    split_tokens[best_idx] = best_id;
+                    // delete token at position best_idx+1, shift the entire sequence back 1
+                    for (int j = best_idx + 1; j < split_n_tokens - 1; j++) {
+                        split_tokens[j] = split_tokens[j + 1];
+                    }
+                    split_n_tokens--; // token length decreased
+                }
+
+                // add the tokens from this split to the output tokens sequence
+                for (int j = 0; j < split_n_tokens; j++) {
+                    tokens[(*n_tokens)++] = split_tokens[j];
+                }
             }
+            // move position past this matched sequence
+            idx += normal_match_len;
         }
 
-        if (best_idx == -1) {
-            break; // we couldn't find any more pairs to merge, so we're done
-        }
+        // now add the special token if one was found
+        if (special_match >= 0) {
+            char matched_str[special_match_len + 1];
+            strncpy(matched_str, text + idx, special_match_len);
+            matched_str[special_match_len] = '\0';
 
-        // merge the consecutive pair (best_idx, best_idx+1) into new token best_id
-        tokens[best_idx] = best_id;
-        // delete token at position best_idx+1, shift the entire sequence back 1
-        for (int i = best_idx+1; i < (*n_tokens-1); i++) {
-            tokens[i] = tokens[i+1];
+            int special_token_id = str_lookup(matched_str, t->sorted_vocab, t->vocab_size);
+            if (special_token_id != -1) {
+                tokens[(*n_tokens)++] = special_token_id;
+            }
+
+            idx += special_match_len;
         }
-        (*n_tokens)--; // token length decreased
     }
 
-    // add optional EOS (=2) token, if desired
-    if (eos) tokens[(*n_tokens)++] = 2;
+    // add optional EOS (=128001) token, if desired
+    if (eos) tokens[(*n_tokens)++] = 128001;
 
     free(str_buffer);
+    pcre_free(re_special);
+    pcre_free(re_normal);
 }
 
 // ----------------------------------------------------------------------------
@@ -810,7 +875,8 @@ void chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,
     int num_prompt_tokens = 0;
     int* prompt_tokens = (int*)malloc(1152 * sizeof(int));
     int user_idx;
-
+    
+    long start = 0;  // used to time our code, only initialized after first iteration
     // start the main loop
     int8_t user_turn = 1; // user starts
     int next;        // will store the next token in the sequence
@@ -840,12 +906,13 @@ void chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,
                 // otherwise get user prompt from stdin
                 read_stdin("User: ", user_prompt, sizeof(user_prompt));
             }
-            // render user/system prompts into the Llama 2 Chat schema
+            // render user/system prompts into the Llama 3 Chat schema
+            // https://www.llama.com/docs/model-cards-and-prompt-formats/meta-llama-3/
             if (pos == 0 && system_prompt[0] != '\0') {
-                char system_template[] = "[INST] <<SYS>>\n%s\n<</SYS>>\n\n%s [/INST]";
+                char system_template[] = "<|start_header_id|>system<|end_header_id|>\n\n%s<|eot_id|><|start_header_id|>user<|end_header_id|>\n\n%s<|eot_id|><|start_header_id|>assistant<|end_header_id|>";
                 sprintf(rendered_prompt, system_template, system_prompt, user_prompt);
             } else {
-                char user_template[] = "[INST] %s [/INST]";
+                char user_template[] = "<|start_header_id|>user<|end_header_id|>\n\n%s<|eot_id|><|start_header_id|>assistant<|end_header_id|>";
                 sprintf(rendered_prompt, user_template, user_prompt);
             }
             // encode the rendered prompt into tokens
@@ -863,23 +930,32 @@ void chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,
             // otherwise use the next token sampled from previous turn
             token = next;
         }
-        // EOS (=2) token ends the Assistant turn
-        if (token == 2) { user_turn = 1; }
+        // <|eot_id|> (=128009) token ends the Assistant turn
+        if ((token == 128001 || token == 128009) && user_idx == num_prompt_tokens) { user_turn = 1; }
 
         // forward the transformer to get logits for the next token
         float* logits = forward(transformer, token, pos);
         next = sample(sampler, logits);
         pos++;
 
-        if (user_idx >= num_prompt_tokens && next != 2) {
+        if (user_idx >= num_prompt_tokens && next != 128009 && next != 128001 && next != 128006) {
             // the Assistant is responding, so print its output
             char* piece = decode(tokenizer, token, next);
             safe_printf(piece); // same as printf("%s", piece), but skips "unsafe" bytes
             fflush(stdout);
+            // init the timer here because the first iteration can be slower
+            if (start == 0) { start = time_in_ms(); }
         }
-        if (next == 2) { printf("\n"); }
+    	if (user_idx >= num_prompt_tokens && next == 128009 || next == 128001) {
+		    printf("\n");
+	    }
     }
     printf("\n");
+    // report achieved tok/s (pos-1 because the timer starts after first iteration)
+    if (pos > 1) {
+        long end = time_in_ms();
+        fprintf(stderr, "achieved tok/s: %f\n", (pos-1) / (double)(end-start)*1000);
+    }
     free(prompt_tokens);
 }
 
diff --git a/runq.c b/runq.c
index 42360ae..c965c66 100644
--- a/runq.c
+++ b/runq.c
@@ -8,6 +8,7 @@
 #include <math.h>
 #include <string.h>
 #include <fcntl.h>
+#include <pcre.h> // for regex splits in tokenizer
 #if defined _WIN32
     #include "win.h"
 #else
@@ -372,7 +373,7 @@ float* forward(Transformer* transformer, int token, int pos) {
         // RoPE relative positional encoding: complex-valued rotate q and k in each head
         for (int i = 0; i < dim; i+=2) {
             int head_dim = i % head_size;
-            float freq = 1.0f / powf(10000.0f, head_dim / (float)head_size);
+            float freq = 1.0f / powf(500000.0f, head_dim / (float)head_size);
             float val = pos * freq;
             float fcr = cosf(val);
             float fci = sinf(val);
@@ -536,8 +537,8 @@ void free_tokenizer(Tokenizer* t) {
 
 char* decode(Tokenizer* t, int prev_token, int token) {
     char *piece = t->vocab[token];
-    // following BOS (1) token, sentencepiece decoder strips any leading whitespace (see PR #89)
-    if (prev_token == 1 && piece[0] == ' ') { piece++; }
+    // following BOS (128000) token, sentencepiece decoder strips any leading whitespace (see PR #89)
+    if (prev_token == 128000 && piece[0] == ' ') { piece++; }
     // careful, some tokens designate raw bytes, and look like e.g. '<0x01>'
     // parse this and convert and return the actual byte
     unsigned char byte_val;
@@ -591,102 +592,166 @@ void encode(Tokenizer* t, char *text, int8_t bos, int8_t eos, int *tokens, int *
     // start at 0 tokens
     *n_tokens = 0;
 
-    // add optional BOS (=1) token, if desired
-    if (bos) tokens[(*n_tokens)++] = 1;
+    // add optional BOS (=128000) token, if desired
+    if (bos) tokens[(*n_tokens)++] = 128000;
 
-    // add_dummy_prefix is true by default
-    // so prepend a dummy prefix token to the input string, but only if text != ""
-    // TODO: pretty sure this isn't correct in the general case but I don't have the
-    // energy to read more of the sentencepiece code to figure out what it's doing
-    if (text[0] != '\0') {
-        int dummy_prefix = str_lookup(" ", t->sorted_vocab, t->vocab_size);
-        tokens[(*n_tokens)++] = dummy_prefix;
+    // regex to force splits from the Meta Llama 3 repo (https://github.com/meta-llama/llama3/blob/main/llama/tokenizer.py): 
+    const char* normal_regex = "(?i:'s|'t|'re|'ve|'m|'ll|'d)|[^\r\n\\p{L}\\p{N}]?\\p{L}+|\\p{N}{1,3}| ?[^\\s\\p{L}\\p{N}]+[\r\n]*|\\s*[\r\n]+|\\s+(?!\\S)|\\s+";
+    // regex for special tokens ex. <|eot_id|>, <|start_header_id|> etc
+    // in the tiktoken code its just all of the specail tokens "or"ed together (https://github.com/openai/tiktoken/blob/main/src/lib.rs#L441)
+    // TODO: add this in tokenizer export
+    const char *special_regex = "<\\|begin_of_text\\|>|<\\|end_of_text\\|>|<\\|start_header_id\\|>|<\\|end_header_id\\|>|<\\|eot_id\\|>|<\\|reserved_special_token_([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|250)\\|>";
+
+    const char *error;
+    int erroffset;
+    pcre *re_special = pcre_compile(special_regex, 0, &error, &erroffset, NULL);
+    pcre *re_normal = pcre_compile(normal_regex, PCRE_UTF8 | PCRE_UCP | PCRE_CASELESS, &error, &erroffset, NULL);
+
+    if (re_special == NULL || re_normal == NULL) {
+        fprintf(stderr, "Failed to compile regex: %s\n", error);
+        exit(EXIT_FAILURE);
     }
 
-    // Okay UTF-8 time. This will get messy. Here is the reference from Wikipedia:
-    // Code point Ôåö UTF-8 conversion
-    // First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
-    // U+0000	U+007F	    0xxxxxxx
-    // U+0080	U+07FF	    110xxxxx	10xxxxxx
-    // U+0800	U+FFFF	    1110xxxx	10xxxxxx	10xxxxxx
-    // U+10000	U+10FFFF    11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
-
-    // process the raw (UTF-8) byte sequence of the input string
-    for (char *c = text; *c != '\0'; c++) {
-
-        // reset buffer if the current byte is ASCII or a leading byte
-        // 0xC0 is 11000000, so (*c & 0xC0) keeps the first 2 bits and zeros the rest
-        // 0x80 is 10000000
-        // in UTF-8, all continuation bytes start with "10" in first two bits
-        // so in English this is: "if this byte is not a continuation byte"
-        if ((*c & 0xC0) != 0x80) {
-            // this byte must be either a leading byte (11...) or an ASCII char (0x...)
-            // => reset our location, as we're starting a new UTF-8 codepoint
-            str_len = 0;
-        }
+    size_t idx = 0;
+    size_t text_len = strlen(text);
 
-        // append the current byte to the buffer
-        str_buffer[str_len++] = *c; // ++ is post-increment, incremented after this line
-        str_buffer[str_len] = '\0';
+    // inspired from the tiktoken code: https://github.com/openai/tiktoken/blob/main/src/lib.rs#L216
+    while (idx < text_len) {
+        int ovector[512];
+        int special_match = pcre_exec(re_special, NULL, text + idx, text_len - idx, 0, 0, ovector, 512);
+        int special_match_len = ovector[1] - ovector[0];
 
-        // while the next character is a continuation byte, continue appending
-        // but if there are too many of them, just stop to avoid overruning str_buffer size.
-        if ((*(c+1) & 0xC0) == 0x80 && str_len < 4) {
-            continue;
-        }
+        size_t end = (special_match >= 0) ? idx + ovector[0] : text_len;
 
-        // ok c+1 is not a continuation byte, so we've read in a full codepoint
-        int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
+        // proces the tokens up to the start of the next special token, or end if there is none
+        while (idx < end) {
+            int normal_match = pcre_exec(re_normal, NULL, text + idx, end - idx, 0, 0, ovector, 512);
+            if (normal_match < 0) break;
 
-        if (id != -1) {
-            // we found this codepoint in vocab, add it as a token
-            tokens[(*n_tokens)++] = id;
-        } else {
-            // byte_fallback encoding: just encode each byte as a token
-            // +3 is here because the first 3 vocab elements are <unk>, <s>, </s>
-            // so the individual bytes only start at index 3
-            for (int i=0; i < str_len; i++) {
-                tokens[(*n_tokens)++] = (unsigned char)str_buffer[i] + 3;
-            }
-        }
-        str_len = 0; // protect against a sequence of stray UTF8 continuation bytes
-    }
+            size_t normal_match_len = ovector[1] - ovector[0];
+            char matched_str[normal_match_len+1];
+            strncpy(matched_str, text + idx, normal_match_len);
+            matched_str[normal_match_len] = '\0';
+
+            int token_id = str_lookup(matched_str, t->sorted_vocab, t->vocab_size);
+
+            // if the split already forms a token, dont run BPE and just use it
+            if (token_id != -1) {
+                tokens[(*n_tokens)++] = token_id;
+            } else {
+                // BPE
+                int split_tokens[1024];
+                int split_n_tokens = 0;
+                char* sequence = matched_str;
+
+                strcpy(str_buffer, sequence);
+
+                // Okay UTF-8 time. This will get messy. Here is the reference from Wikipedia:
+                // Code point Ôåö UTF-8 conversion
+                // First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
+                // U+0000	U+007F	    0xxxxxxx
+                // U+0080	U+07FF	    110xxxxx	10xxxxxx
+                // U+0800	U+FFFF	    1110xxxx	10xxxxxx	10xxxxxx
+                // U+10000	U+10FFFF    11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
+                // process the raw (UTF-8) byte sequence of the input string
+                size_t str_len = 0;
+                for (char *c = sequence; *c != '\0'; c++) {
+                    // reset buffer if the current byte is ASCII or a leading byte
+                    // 0xC0 is 11000000, so (*c & 0xC0) keeps the first 2 bits and zeros the rest
+                    // 0x80 is 10000000
+                    // in UTF-8, all continuation bytes start with "10" in first two bits
+                    // so in English this is: "if this byte is not a continuation byte"
+                    if ((*c & 0xC0) != 0x80) {
+                        // this byte must be either a leading byte (11...) or an ASCII char (0x...)
+                        // => reset our location, as we're starting a new UTF-8 codepoint
+                        str_len = 0;
+                    }
+
+                    // append the current byte to the buffer
+                    str_buffer[str_len++] = *c; // ++ is post-increment, incremented after this line
+                    str_buffer[str_len] = '\0';
+
+                    // while the next character is a continuation byte, continue appending
+                    // but if there are too many of them, just stop to avoid overruning str_buffer size.
+                    if ((*(c+1) & 0xC0) == 0x80 && str_len < 4) {
+                        continue;
+                    }
+                    // ok c+1 is not a continuation byte, so we've read in a full codepoint
+                    int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
+                    if (id != -1) {
+                        // we found this codepoint in vocab, add it as a token
+                        split_tokens[split_n_tokens++] = id;
+                    } else {
+                        // byte_fallback encoding: just encode each byte as a token
+                        for (int j=0; j < str_len; j++) {
+                            split_tokens[split_n_tokens++] = (unsigned char)str_buffer[j];
+                        }
+                    }
+                    str_len = 0; // protect against a sequence of stray UTF8 continuation bytes
+                }
+
+                // merge the best consecutive pair each iteration, according the scores in vocab_scores
+                while (1) {
+                    float best_score = 1e10;
+                    int best_id = -1;
+                    int best_idx = -1;
+
+                    for (int j = 0; j < split_n_tokens - 1; j++) {
+                        // check if we can merge the pair (tokens[i], tokens[i+1])
+                        sprintf(str_buffer, "%s%s", t->vocab[split_tokens[j]], t->vocab[split_tokens[j + 1]]);
+                        int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
+
+                        if (id != -1 && t->vocab_scores[id] < best_score) {
+                            // this merge pair exists in vocab! record its score and position
+                            best_score = t->vocab_scores[id];
+                            best_id = id;
+                            best_idx = j;
+                        }
+                    }
+
+                    if (best_idx == -1) {
+                        break; // we couldn't find any more pairs to merge, so we're done
+                    }
+
+                    // merge the consecutive pair (best_idx, best_idx+1) into new token best_id
+                    split_tokens[best_idx] = best_id;
+                    // delete token at position best_idx+1, shift the entire sequence back 1
+                    for (int j = best_idx + 1; j < split_n_tokens - 1; j++) {
+                        split_tokens[j] = split_tokens[j + 1];
+                    }
+                    split_n_tokens--; // token length decreased
+                }
 
-    // merge the best consecutive pair each iteration, according the scores in vocab_scores
-    while (1) {
-        float best_score = -1e10;
-        int best_id = -1;
-        int best_idx = -1;
-
-        for (int i=0; i < (*n_tokens-1); i++) {
-            // check if we can merge the pair (tokens[i], tokens[i+1])
-            sprintf(str_buffer, "%s%s", t->vocab[tokens[i]], t->vocab[tokens[i+1]]);
-            int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);
-            if (id != -1 && t->vocab_scores[id] > best_score) {
-                // this merge pair exists in vocab! record its score and position
-                best_score = t->vocab_scores[id];
-                best_id = id;
-                best_idx = i;
+                // add the tokens from this split to the output tokens sequence
+                for (int j = 0; j < split_n_tokens; j++) {
+                    tokens[(*n_tokens)++] = split_tokens[j];
+                }
             }
+            // move position past this matched sequence
+            idx += normal_match_len;
         }
 
-        if (best_idx == -1) {
-            break; // we couldn't find any more pairs to merge, so we're done
-        }
+        // now add the special token if one was found
+        if (special_match >= 0) {
+            char matched_str[special_match_len + 1];
+            strncpy(matched_str, text + idx, special_match_len);
+            matched_str[special_match_len] = '\0';
+
+            int special_token_id = str_lookup(matched_str, t->sorted_vocab, t->vocab_size);
+            if (special_token_id != -1) {
+                tokens[(*n_tokens)++] = special_token_id;
+            }
 
-        // merge the consecutive pair (best_idx, best_idx+1) into new token best_id
-        tokens[best_idx] = best_id;
-        // delete token at position best_idx+1, shift the entire sequence back 1
-        for (int i = best_idx+1; i < (*n_tokens-1); i++) {
-            tokens[i] = tokens[i+1];
+            idx += special_match_len;
         }
-        (*n_tokens)--; // token length decreased
     }
 
-    // add optional EOS (=2) token, if desired
-    if (eos) tokens[(*n_tokens)++] = 2;
+    // add optional EOS (=128001) token, if desired
+    if (eos) tokens[(*n_tokens)++] = 128001;
 
     free(str_buffer);
+    pcre_free(re_special);
+    pcre_free(re_normal);
 }
 
 // ----------------------------------------------------------------------------
@@ -929,7 +994,8 @@ void chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,
     int num_prompt_tokens = 0;
     int* prompt_tokens = (int*)malloc(1152 * sizeof(int));
     int user_idx;
-
+    
+    long start = 0;  // used to time our code, only initialized after first iteration
     // start the main loop
     int8_t user_turn = 1; // user starts
     int next;        // will store the next token in the sequence
@@ -959,12 +1025,13 @@ void chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,
                 // otherwise get user prompt from stdin
                 read_stdin("User: ", user_prompt, sizeof(user_prompt));
             }
-            // render user/system prompts into the Llama 2 Chat schema
+            // render user/system prompts into the Llama 3 Chat schema
+            // https://www.llama.com/docs/model-cards-and-prompt-formats/meta-llama-3/
             if (pos == 0 && system_prompt[0] != '\0') {
-                char system_template[] = "[INST] <<SYS>>\n%s\n<</SYS>>\n\n%s [/INST]";
+                char system_template[] = "<|start_header_id|>system<|end_header_id|>\n\n%s<|eot_id|><|start_header_id|>user<|end_header_id|>\n\n%s<|eot_id|><|start_header_id|>assistant<|end_header_id|>";
                 sprintf(rendered_prompt, system_template, system_prompt, user_prompt);
             } else {
-                char user_template[] = "[INST] %s [/INST]";
+                char user_template[] = "<|start_header_id|>user<|end_header_id|>\n\n%s<|eot_id|><|start_header_id|>assistant<|end_header_id|>";
                 sprintf(rendered_prompt, user_template, user_prompt);
             }
             // encode the rendered prompt into tokens
@@ -982,23 +1049,31 @@ void chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,
             // otherwise use the next token sampled from previous turn
             token = next;
         }
-        // EOS (=2) token ends the Assistant turn
-        if (token == 2) { user_turn = 1; }
-
-        // forward the transformer to get logits for the next token
+        // <|eot_id|> (=128009) token ends the Assistant turn
+        if ((token == 128009 || token == 128001) && user_idx == num_prompt_tokens) { user_turn = 1; }
+        
+	    // forward the transformer to get logits for the next token
         float* logits = forward(transformer, token, pos);
         next = sample(sampler, logits);
         pos++;
-
-        if (user_idx >= num_prompt_tokens && next != 2) {
+	    if (user_idx >= num_prompt_tokens && next != 128009 && next != 128001 && next != 128006) {
             // the Assistant is responding, so print its output
             char* piece = decode(tokenizer, token, next);
             safe_printf(piece); // same as printf("%s", piece), but skips "unsafe" bytes
             fflush(stdout);
+            // init the timer here because the first iteration can be slower
+            if (start == 0) { start = time_in_ms(); }
+        }
+        if (user_idx >= num_prompt_tokens && next == 128009 || next == 128001) {
+            printf("\n");
         }
-        if (next == 2) { printf("\n"); }
     }
     printf("\n");
+    // report achieved tok/s (pos-1 because the timer starts after first iteration)
+    if (pos > 1) {
+        long end = time_in_ms();
+        fprintf(stderr, "achieved tok/s: %f\n", (pos-1) / (double)(end-start)*1000);
+    }
     free(prompt_tokens);
 }
 
diff --git a/test.c b/test.c
index 4203efd..f2a52f4 100644
--- a/test.c
+++ b/test.c
@@ -41,39 +41,68 @@ void test_prompt_encodings() {
     // let's verify that the Tokenizer works as expected
 
     char *tokenizer_path = "tokenizer.bin";
-    int vocab_size = 32000;
+    int vocab_size = 128256;
     Tokenizer tokenizer;
     build_tokenizer(&tokenizer, tokenizer_path, vocab_size);
 
     // test 0 (test the empty string) (I added this as a simple case)
     char *prompt0 = "";
-    int expected_tokens0[] = {1};
+    int expected_tokens0[] = {128000};
     test_prompt_encoding(&tokenizer, prompt0, expected_tokens0, sizeof(expected_tokens0) / sizeof(int));
 
     // the tests below are taken from the Meta Llama 2 repo example code
     // https://github.com/facebookresearch/llama/blob/main/example_text_completion.py
-    // and the expected tokens come from me breaking in the debugger in Python
+    // I updated the token ids to match the llama3.2 tokenizer
 
     // test 1
     char *prompt = "I believe the meaning of life is";
-    int expected_tokens[] = {1, 306, 4658, 278, 6593, 310, 2834, 338};
+    int expected_tokens[] = {128000, 40, 4510, 279, 7438, 315, 2324, 374};
     test_prompt_encoding(&tokenizer, prompt, expected_tokens, sizeof(expected_tokens) / sizeof(int));
 
     // test 2
     char* prompt2 = "Simply put, the theory of relativity states that ";
-    int expected_tokens2[] = {1, 3439, 17632, 1925, 29892, 278, 6368, 310, 14215, 537, 5922, 393, 29871};
+    int expected_tokens2[] = {128000, 61346, 2231, 11, 279, 10334, 315, 1375, 44515, 5415, 430, 220};
     test_prompt_encoding(&tokenizer, prompt2, expected_tokens2, sizeof(expected_tokens2) / sizeof(int));
 
     // test 3
     char* prompt3 = "A brief message congratulating the team on the launch:\n\n        Hi everyone,\n\n        I just ";
-    int expected_tokens3[] = {1, 319, 11473, 2643, 378, 629, 271, 18099, 278, 3815, 373, 278, 6826, 29901, 13, 13, 4706, 6324, 14332, 29892, 13, 13, 4706, 306, 925, 29871};
+    int expected_tokens3[] = {128000, 32, 10015, 1984, 40588, 15853, 279, 2128, 389, 279, 7195, 1473, 286, 21694, 5127, 3638, 286, 358, 1120, 220};
     test_prompt_encoding(&tokenizer, prompt3, expected_tokens3, sizeof(expected_tokens3) / sizeof(int));
 
     // test 4
     char* prompt4 = "Translate English to French:\n\n        sea otter => loutre de mer\n        peppermint => menthe poivr├®e\n        plush girafe => girafe peluche\n        cheese =>";
-    int expected_tokens4[] = {1, 4103, 9632, 4223, 304, 5176, 29901, 13, 13, 4706, 7205, 4932, 357, 1149, 301, 449, 276, 316, 2778, 13, 4706, 1236, 407, 837, 524, 1149, 6042, 354, 772, 440, 29878, 1318, 13, 4706, 715, 1878, 330, 3055, 1725, 1149, 330, 3055, 1725, 4639, 28754, 13, 4706, 923, 968, 1149};
+    int expected_tokens4[] = {128000, 28573, 6498, 311, 8753, 1473, 286, 9581, 14479, 466, 591, 326, 412, 265, 409, 4809, 198, 286, 83804, 94932, 591, 11540, 383, 3273, 58866, 8047, 198, 286, 72779, 41389, 5763, 591, 41389, 5763, 12077, 34927, 198, 286, 17604, 591};
     test_prompt_encoding(&tokenizer, prompt4, expected_tokens4, sizeof(expected_tokens4) / sizeof(int));
 
+    // more tests generated by chatgpt
+    char* prompt5 = "Let's test with numbers: 123, 456.";
+    int expected_tokens5[] = {128000, 10267, 596, 1296, 449, 5219, 25, 220, 4513, 11, 220, 10961, 13};
+    test_prompt_encoding(&tokenizer, prompt5, expected_tokens5, sizeof(expected_tokens5) / sizeof(int));
+
+    char* prompt6 = "Newline\nand special chars: @#!.";
+    int expected_tokens6[] = {128000, 3648, 1074, 198, 438, 3361, 23861, 25, 571, 8169, 13};
+    test_prompt_encoding(&tokenizer, prompt6, expected_tokens6, sizeof(expected_tokens6) / sizeof(int));
+
+    char* prompt7 = "Whitespace     and     tabs.";
+    int expected_tokens7[] = {128000, 74904, 257, 323, 257, 23204, 13};
+    test_prompt_encoding(&tokenizer, prompt7, expected_tokens7, sizeof(expected_tokens7) / sizeof(int));
+
+    char* prompt8 = "'ve got contractions, haven't we?";
+    int expected_tokens8[] = {128000, 3077, 2751, 6155, 4109, 11, 9167, 956, 584, 30};
+    test_prompt_encoding(&tokenizer, prompt8, expected_tokens8, sizeof(expected_tokens8) / sizeof(int));
+
+    char* prompt9 = "<|start_header_id|>system<|end_header_id|>\n\nYou are a helpful AI assistant for travel tips and recommendations<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nWhat can you help me with?<|eot_id|><|start_header_id|>assistant<|end_header_id|>";
+    int expected_tokens9[] = {128000, 128006, 9125, 128007, 271, 2675, 527, 264, 11190, 15592, 18328, 369, 5944, 10631, 323, 19075, 128009, 128006, 882, 128007, 271, 3923, 649, 499, 1520, 757, 449, 30, 128009, 128006, 78191, 128007};
+    test_prompt_encoding(&tokenizer, prompt9, expected_tokens9, sizeof(expected_tokens9) / sizeof(int));
+
+    char* prompt10 = "<|not_a_special_token|><|this_should_split_normally|>";
+    int expected_tokens10[] = {128000, 27, 91, 1962, 4404, 42729, 6594, 91, 1822, 91, 576, 44478, 17489, 19731, 750, 91, 29};
+    test_prompt_encoding(&tokenizer, prompt10, expected_tokens10, sizeof(expected_tokens10) / sizeof(int));
+
+    char* prompt11 = "<|reserved_special_token_0|><|reserved_special_token_125|><|reserved_special_token_247|><|reserved_special_token_777|>";
+    int expected_tokens11[] = {128000, 128002, 128130, 128252, 27, 91, 52202, 42729, 6594, 62, 15831, 91, 29};
+    test_prompt_encoding(&tokenizer, prompt11, expected_tokens11, sizeof(expected_tokens11) / sizeof(int));
+
     // memory and file handles cleanup
     free_tokenizer(&tokenizer);
 }
diff --git a/tokenizer.bin b/tokenizer.bin
index e6c1b23..eccc187 100644
Binary files a/tokenizer.bin and b/tokenizer.bin differ
diff --git a/tokenizer.model b/tokenizer.model
index 22bccbc..f0a0ce5 100644
Binary files a/tokenizer.model and b/tokenizer.model differ
diff --git a/tokenizer.py b/tokenizer.py
index f3c0cc3..098b925 100644
--- a/tokenizer.py
+++ b/tokenizer.py
@@ -1,43 +1,142 @@
-# Taken from llama code and lightly modified
+# taken from the llama code and lightly modified (https://github.com/meta-llama/llama3/blob/main/llama/tokenizer.py)
 # Copyright (c) Meta Platforms, Inc. and affiliates.
-# This software may be used and distributed according to the terms of the Llama 2 Community License Agreement.
+# This software may be used and distributed in accordance with the terms of the Llama 3 Community License Agreement.
 
 import os
-import struct
+from pathlib import Path
+from typing import (
+    AbstractSet,
+    cast,
+    Collection,
+    Dict,
+    Iterator,
+    List,
+    Literal,
+    Sequence,
+    TypedDict,
+    Union,
+)
 import argparse
-from typing import List
+import struct
 
-from sentencepiece import SentencePieceProcessor
+import tiktoken
+from tiktoken.load import load_tiktoken_bpe
 
-TOKENIZER_MODEL = "tokenizer.model" # the llama sentencepiece tokenizer model
+TOKENIZER_MODEL = "tokenizer.model"
 
 class Tokenizer:
-    def __init__(self, tokenizer_model=None):
-        model_path = tokenizer_model if tokenizer_model else TOKENIZER_MODEL
+    """
+    Tokenizing and encoding/decoding text using the Tiktoken tokenizer.
+    """
+
+    pat_str = r"(?i:'s|'t|'re|'ve|'m|'ll|'d)|[^\r\n\p{L}\p{N}]?\p{L}+|\p{N}{1,3}| ?[^\s\p{L}\p{N}]+[\r\n]*|\s*[\r\n]+|\s+(?!\S)|\s+"  # noqa: E501
+
+    def __init__(self, model_path: str=None):
+        """
+        Initializes the Tokenizer with a Tiktoken model.
+
+        Args:
+            model_path (str): The path to the Tiktoken model file.
+        """
+        model_path = model_path if model_path else TOKENIZER_MODEL
         assert os.path.isfile(model_path), model_path
-        self.sp_model = SentencePieceProcessor(model_file=model_path)
         self.model_path = model_path
+        self.mergeable_ranks = load_tiktoken_bpe(model_path)
+        num_base_tokens = len(self.mergeable_ranks)
+        num_reserved_special_tokens = 256
+
+        special_tokens = [
+            "<|begin_of_text|>",
+            "<|end_of_text|>",
+            "<|reserved_special_token_0|>",
+            "<|reserved_special_token_1|>",
+            "<|reserved_special_token_2|>",
+            "<|reserved_special_token_3|>",
+            "<|start_header_id|>",
+            "<|end_header_id|>",
+            "<|reserved_special_token_4|>",
+            "<|eot_id|>",  # end of turn
+        ] + [
+            f"<|reserved_special_token_{i}|>"
+            for i in range(5, num_reserved_special_tokens - 5)
+        ]
+        self.special_tokens = {
+            token: num_base_tokens + i for i, token in enumerate(special_tokens)
+        }
+        self.model = tiktoken.Encoding(
+            name=Path(model_path).name,
+            pat_str=self.pat_str,
+            mergeable_ranks=self.mergeable_ranks,
+            special_tokens=self.special_tokens,
+        )
 
+        self.n_words: int = self.model.n_vocab
         # BOS / EOS token IDs
-        self.n_words: int = self.sp_model.vocab_size()
-        self.bos_id: int = self.sp_model.bos_id()
-        self.eos_id: int = self.sp_model.eos_id()
-        self.pad_id: int = self.sp_model.pad_id()
-        #print(f"#words: {self.n_words} - BOS ID: {self.bos_id} - EOS ID: {self.eos_id}")
-        assert self.sp_model.vocab_size() == self.sp_model.get_piece_size()
-
-    def encode(self, s: str, bos: bool, eos: bool) -> List[int]:
+        self.bos_id: int = self.special_tokens["<|begin_of_text|>"]
+        self.eos_id: int = self.special_tokens["<|end_of_text|>"]
+        self.pad_id: int = -1
+        self.stop_tokens = {
+            self.special_tokens["<|end_of_text|>"],
+            self.special_tokens["<|eot_id|>"],
+        }
+
+    def encode(
+        self,
+        s: str,
+        *,
+        bos: bool,
+        eos: bool,
+        allowed_special: Union[Literal["all"], AbstractSet[str]] = set(),
+        disallowed_special: Union[Literal["all"], Collection[str]] = (),
+    ) -> List[int]:
+        """
+        Encodes a string into a list of token IDs.
+
+        Args:
+            s (str): The input string to be encoded.
+            bos (bool): Whether to prepend the beginning-of-sequence token.
+            eos (bool): Whether to append the end-of-sequence token.
+            allowed_tokens ("all"|set[str]): allowed special tokens in string
+            disallowed_tokens ("all"|set[str]): special tokens that raise an error when in string
+
+        Returns:
+            list[int]: A list of token IDs.
+
+        By default, setting disallowed_special=() encodes a string by ignoring
+        special tokens. Specifically:
+        - Setting `disallowed_special` to () will cause all text corresponding
+          to special tokens to be encoded as natural text (insteading of raising
+          an error).
+        - Setting `allowed_special` to "all" will treat all text corresponding
+          to special tokens to be encoded as special tokens.
+        """
         assert type(s) is str
-        t = self.sp_model.encode(s)
+
+        self.model.encode(
+            substr,
+            allowed_special=allowed_special,
+            disallowed_special=disallowed_special,
+        )
+
         if bos:
-            t = [self.bos_id] + t
+            t.insert(0, self.bos_id)
         if eos:
-            t = t + [self.eos_id]
+            t.append(self.eos_id)
         return t
 
-    def decode(self, t: List[int]) -> str:
-        return self.sp_model.decode(t)
+    def decode(self, t: Sequence[int]) -> str:
+        """
+        Decodes a list of token IDs into a string.
 
+        Args:
+            t (List[int]): The list of token IDs to be decoded.
+
+        Returns:
+            str: The decoded string.
+        """
+        # Typecast is safe here. Tiktoken doesn't do anything list-related with the sequence.
+        return self.model.decode(cast(List[int], t))
+    
     def export(self):
 
         # get all the tokens (postprocessed) and their scores as floats
@@ -45,18 +144,15 @@ class Tokenizer:
         for i in range(self.n_words):
 
             # decode the token and light postprocessing
-            t = self.sp_model.id_to_piece(i)
-            s = self.sp_model.get_score(i)
-            if i == self.bos_id:
-                t = '\n<s>\n'
-            elif i == self.eos_id:
-                t = '\n</s>\n'
-            t = t.replace('Ôûü', ' ') # sentencepiece uses this character as whitespace
-            b = t.encode('utf-8') # bytes of this token, utf-8 encoded
-
-            tokens.append(b)
-            scores.append(s)
+            t = self.model.decode_single_token_bytes(i)
+            if t in self.mergeable_ranks:
+                s = self.mergeable_ranks[t]
+            elif t.decode("utf-8") in self.special_tokens:
+                s = self.special_tokens[t.decode("utf-8")]
 
+            tokens.append(t)
+            scores.append(s)
+        
         # record the max token length
         max_token_length = max(len(t) for t in tokens)
 
@@ -75,4 +171,4 @@ if __name__ == "__main__":
     args = parser.parse_args()
 
     t = Tokenizer(args.tokenizer_model)
-    t.export()
+    t.export()
\ No newline at end of file
